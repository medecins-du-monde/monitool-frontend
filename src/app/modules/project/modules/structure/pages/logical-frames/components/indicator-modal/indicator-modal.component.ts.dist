import { Component, Inject, OnInit } from '@angular/core';
import { AbstractControl, FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { Parser } from 'expr-eval';
import { forEach } from 'lodash';
import { BehaviorSubject } from 'rxjs';
import { Form } from 'src/app/models/form.model';
import { COPY_FORMULA, PERCENTAGE_FORMULA, PERMILLE_FORMULA } from 'src/app/models/project-indicator.model';

@Component({
  selector: 'app-indicator-modal',
  templateUrl: './indicator-modal.component.html',
  styleUrls: ['./indicator-modal.component.scss']
})
export class IndicatorModalComponent implements OnInit {

  displayedColumns: string[] = ['parameter', 'variable', 'disaggregations'];
  dataSource = new BehaviorSubject<any[]>([]);


  private initValue: {};
  private parser: Parser;
  private symbols: any;

  public computationTypes = [
    {
      value: 'unavailable',
      display: 'Enum.Computation.unavailable'
    },
    {
      value: 'fixed',
      display: 'Enum.Computation.fixed'
    },
    {
      value: 'copy',
      display: 'Enum.Computation.copy'
    },
    {
      value: 'percentage',
      display: 'Enum.Computation.percentage'
    },
    {
      value: 'permille',
      display: 'Enum.Computation.permille'
    },
    {
      value: 'formula',
      display: 'Enum.Computation.formula'
    },
  ];

  get type() {
    return this.data.indicator.value.type;
  }

  constructor(
    private fb: FormBuilder,
    public dialogRef: MatDialogRef<IndicatorModalComponent>,
    @Inject(MAT_DIALOG_DATA) public data: {Â indicator: FormGroup, forms: Form[] }
  ) { }

  ngOnInit(): void {
    this.initValue = this.data.indicator.value;
    this.parser = new Parser();
    this.parser.consts = {};
    try {
      this.symbols = this.parser.parse(this.data.indicator.value.computation.formula).variables();
      this.dataSource.next(this.symbols);
    }
    catch (e) {
      this.symbols = [];
    }
  }

  onSubmit() {
    console.log('on Submit...');
    console.log('data indicator : ');
    console.log(this.data.indicator);
    this.dialogRef.close({ indicator: this.data.indicator });
  }

  onReset() {
    this.data.indicator.setValue(this.initValue);
  }

  onTypeChange(type: any) {
    const computation = this.data.indicator.controls.computation as FormGroup;
    if (type.value === 'fixed' && isNaN(computation.value.formula)) {
      computation.controls.formula.setValue('0');
    } else if (type.value === 'copy') {
      computation.controls.formula.setValue(COPY_FORMULA);
    } else if (type.value === 'percentage') {
      computation.controls.formula.setValue(PERCENTAGE_FORMULA);
    } else if (type.value === 'permille') {
      computation.controls.formula.setValue(PERMILLE_FORMULA);
    }
    this.onFormulaChange();
  }

  onFormulaChange() {
    console.log('formula changing...');
    const parameters = this.data.indicator.controls.computation.value.parameters ?
      this.data.indicator.controls.computation.value.parameters : {};

    let newSymbols = Object.keys(parameters);
    const oldSymbols = Object.keys(parameters);

    try {
      newSymbols = this.parser.parse(this.data.indicator.controls.computation.value.formula).variables();
    }
    catch (e) {
      newSymbols = [];
    }

    // if (!(JSON.stringify(newSymbols) === JSON.stringify(oldSymbols))) {
    //   const addedSymbols = newSymbols.filter(s => !oldSymbols.includes(s));

    //   // Add new symbols to formula
    //   addedSymbols.forEach(s => {
    //     parameters[s] = { elementId: null, filter: {} };
    //   });
    // }

    this.symbols = newSymbols;
    const computation = this.data.indicator.controls.computation as FormGroup;
    const parametersFormGroup = this.fb.group({});
    const calculDataList = [];
    for (let i = 0; i < this.symbols.length; i++ ) {
      // forEach(this.data.forms[0].elements[i].partitions, partition => {
      //   console.log('I am the partition : ')
      //   console.log(partition)
      //   const valuesPartition = [];
      //   forEach(partition.elements, value => {
      //     valuesPartition.push(value.id);
      //   });
      //   listFilters.push({
      //     [partition.id]: valuesPartition,
      //   });
      // });
      console.log("this.data.forms[0].elements[i] : ")
      console.log(this.data.forms[0].elements[i])

      calculDataList.push({
        key: this.symbols[i],
        value: this.data.forms[0].elements[i]
      });
      const parameterGroup = this.fb.group({
        elementId: [this.data.forms[0].elements[i].id || '', Validators.required],
        // filter: [listFilters, Validators.required]
        filter: []
      });
      parametersFormGroup.addControl(`${this.symbols[i]}`, parameterGroup);
    }
    console.log('parameters :')
    console.log(parameters)
    this.data.indicator.controls.computation = this.fb.group({
      formula: computation.value.formula,
      // parameters: parameters === {} ? parametersFormGroup : parameters,
      parameters: parametersFormGroup,
    });
    console.log('this.data.indicator.controls.computation : ')
    console.log(this.data.indicator.controls.computation)

    // const calculDataList = [];
    // forEach(parametersFormGroup.value, (value, key) => {
    //   calculDataList.push( {
    //     key,
    //     value,
    //   } );
    // });
    console.log('Here is the calculDataList : ')
    console.log(calculDataList)
    this.dataSource.next(calculDataList);
    console.log("Here is the this.data.indicator.controls.computation :")
    console.log(this.data.indicator.controls.computation)
  }

  onVariableSelected(element: any, symbol: string) {
    const newValue = this.data.forms[0].elements.find(data => data.id === element.value);
    this.dataSource.value.map(parameter => {
      if (parameter.key === symbol) {
         parameter.value.elementId = newValue.id;
         parameter.value.filter = newValue.partitions;
        }
    });
    console.log('here is the datasource : ')
    console.log(this.dataSource)
    // const computation = this.data.indicator.controls.computation as FormGroup;
    // const parametersFormGroup = this.fb.group({});
    // for (let i = 0; i < this.dataSource.value.length; i++ ) {
    //   const parameterGroup = this.fb.group({
    //     elementId: [this.dataSource.value[i].elementId || '', Validators.required],
    //     filter: [this.dataSource.value[i].partitions ? this.dataSource.value[i].partitions.filter || {} : {}, Validators.required]
    //   });
    //   parametersFormGroup.addControl(`${this.symbols[i]}`, parameterGroup);
    // }
    // this.data.indicator.controls.computation = this.fb.group({
    //   formula: computation.value.formula,
    //   parameters: parametersFormGroup
    // });
    // console.log('computation')
    // console.log(computation)
    console.log('this.datasource.value :')
    console.log(this.dataSource.value)
  }
}
